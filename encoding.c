#include <stdio.h>
#include "encoding.h"

unsigned char power_polynomial_table[GF_FIELD][2] = 
{
	/*power <---> polynomial*/
	/*These are also the coefficients of generator polynomials.*/
	{0xFF, 0x0},
	{0x0, 0x1},
	{0x1, 0x2},
	{0x2, 0x4},
	{0x3, 0x8},
	{0x4, 0x3},
	{0x5, 0x6},
	{0x6, 0xC},
	{0x7, 0xB},
	{0x8, 0x5},
	{0x9, 0xA},
	{0xA, 0x7},
	{0xB, 0xE},
	{0xC, 0xF},
	{0xD, 0xD},
	{0xE, 0x9}
};

unsigned char generator_polynomial[CODEWORD_LEN - MESSAGE_LEN + 1] =
{
	/*generated by MATLAB: genpoly = rsgenpoly(n, k, prim_poly)*/
	0xC,
	0xA,
	0xC,
	0x3,
	0x9,
	0x7,
	0x1
};

unsigned char message_polynomial[MESSAGE_LEN] = 
{
	/*power representation*/
	0x1,
	0x4,
	0x4,
	0x2,
	0x7,
	0xD,
	0x6,
	0x0,
	0x6
};

unsigned char gf_pow2poly(unsigned char val_in_pow)
{
	unsigned char val_in_poly = 0;

	return power_polynomial_table[val_in_pow + 1][1];
}

unsigned char gf_poly2pow(unsigned char val_in_poly)
{
	unsigned char i = 0;
	unsigned char val_in_pow = 0;

	for(i = 0; i < GF_FIELD; i++)
	{
		if(power_polynomial_table[i][1] == val_in_poly)
		{
			val_in_pow = power_polynomial_table[i][0];
			break;
		}
	}

	return val_in_pow;
}

unsigned char gf_location(unsigned char val)
{
	unsigned char val_location = power_polynomial_table[val + 1][0];

	return val_location;
}

unsigned char gf_add(unsigned char a, unsigned char b)
{
	unsigned char i = 0;
	unsigned char sum_in_pow = 0;
	
	unsigned char sum_in_poly = gf_pow2poly(a) ^ gf_pow2poly(b);

	sum_in_pow = gf_poly2pow(sum_in_poly);

	return sum_in_pow;
}

unsigned char gf_multp(unsigned char a, unsigned char b)
{
	unsigned char product_in_pow = (a + b) % (GF_FIELD - 1);

	return product_in_pow;
}

unsigned char evaluation_encoding()
{
	unsigned char i = 0, j = 0;
	unsigned char tmp_power_result[MESSAGE_LEN], tmp_add_result = 0;

	unsigned char codeword[CODEWORD_LEN];

	for(i = 0; i < CODEWORD_LEN; i++)
	{
		for(j = 0; j < MESSAGE_LEN; j++)
		{
			//tmp_power_result[j] = (message_polynomial[j] + i * power_polynomial_table[j + 1][0]) % (GF_FIELD - 1);
			tmp_power_result[j] = gf_multp(message_polynomial[j], i * gf_location(j));
			//printf("tmp_power_result: %d %d %x\n", i, j, tmp_power_result[j]);
		}
		tmp_add_result = 0;
		for(j = 0; j < MESSAGE_LEN; j++)
		{
			//tmp_add_result = power_polynomial_table[tmp_power_result[j] + 1][1] ^ tmp_add_result;
			tmp_add_result = gf_pow2poly(tmp_power_result[j]) ^ tmp_add_result;
			//printf("tmp_add_result: %d %d %x %x %x\n", i, j, power_polynomial_table[tmp_power_result[j] + 1][1], tmp_power_result[j], tmp_add_result);
		}

		for(j = 0; j < GF_FIELD; j++)
		{
#if 0
			if(power_polynomial_table[j][1] == tmp_add_result)
			{
				codeword[i] = power_polynomial_table[j][0];
				break;
			}
#endif
			codeword[i] = gf_poly2pow(tmp_add_result);
		}
	}

	printf("Evaluation Encoding Codeword:\n");
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		printf("%x ", codeword[i]);
	}
	printf("\n");

	return 0;
}

unsigned char systematic_encoding()
{
	unsigned char i = 0;
	
	unsigned char clock_cycle = 0;
	unsigned char input_message = 0;
	unsigned char feed_back_reg = 0, reg_delay[CODEWORD_LEN - MESSAGE_LEN] = 
	{
		0,
		0,
		0,
		0,
		0,
		0
	};
	unsigned char codeword[CODEWORD_LEN];

	/*for iterating calculation, tmp for C, not in HDL*/
	unsigned char feed_back_reg_prev = feed_back_reg, reg_delay_prev[CODEWORD_LEN - MESSAGE_LEN] = 
	{
		reg_delay[0],
		reg_delay[1],
		reg_delay[2],
		reg_delay[3],
		reg_delay[4],
		reg_delay[5]
	};

	for(clock_cycle = 0; clock_cycle < (CODEWORD_LEN - MESSAGE_LEN); clock_cycle++)
	{
		input_message = message_polynomial[MESSAGE_LEN - 1 - clock_cycle];
		
		feed_back_reg = gf_add(input_message, reg_delay_prev[5]);
		reg_delay[5] = gf_add(gf_multp(feed_back_reg_prev, generator_polynomial[5]), reg_delay_prev[4]);
		reg_delay[4] = gf_add(gf_multp(feed_back_reg_prev, generator_polynomial[4]), reg_delay_prev[3]);
		reg_delay[3] = gf_add(gf_multp(feed_back_reg_prev, generator_polynomial[3]), reg_delay_prev[2]);
		reg_delay[2] = gf_add(gf_multp(feed_back_reg_prev, generator_polynomial[2]), reg_delay_prev[1]);
		reg_delay[1] = gf_add(gf_multp(feed_back_reg_prev, generator_polynomial[1]), reg_delay_prev[0]);
		reg_delay[0] = gf_multp(feed_back_reg_prev, generator_polynomial[0]);

		feed_back_reg_prev = feed_back_reg;
		reg_delay_prev[5] = reg_delay[5];
		reg_delay_prev[4] = reg_delay[4];
		reg_delay_prev[3] = reg_delay[3];
		reg_delay_prev[2] = reg_delay[2];
		reg_delay_prev[1] = reg_delay[1];
		reg_delay_prev[0] = reg_delay[0];
	}

	for(i = CODEWORD_LEN - MESSAGE_LEN; i < CODEWORD_LEN; i++)
	{
		codeword[i] = message_polynomial[i - (CODEWORD_LEN - MESSAGE_LEN)];
	}
	for(i = 0; i < CODEWORD_LEN - MESSAGE_LEN; i++)
	{
		codeword[i] = reg_delay[i];
	}

	printf("Systematic Encoding Codeword:\n");
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		printf("%x ", codeword[i]);
	}
	printf("\n");

	return 0;
}
