#include <stdio.h>
#include <string.h>
#include "encoding.h"

#if (1 == GF_16_CASE)
unsigned char power_polynomial_table[GF_FIELD][2] = 
{
	/*power <---> polynomial*/
	/*These are also the coefficients of generator polynomials.*/
	{0xFF, 0x0},
	{0x0, 0x1},
	{0x1, 0x2},
	{0x2, 0x4},
	{0x3, 0x8},
	{0x4, 0x3},
	{0x5, 0x6},
	{0x6, 0xC},
	{0x7, 0xB},
	{0x8, 0x5},
	{0x9, 0xA},
	{0xA, 0x7},
	{0xB, 0xE},
	{0xC, 0xF},
	{0xD, 0xD},
	{0xE, 0x9}
};

unsigned char generator_polynomial[CODEWORD_LEN - MESSAGE_LEN + 1] =
{
	/*generated by MATLAB: genpoly = rsgenpoly(n, k, prim_poly)*/
	0xC,
	0xA,
	0xC,
	0x3,
	0x9,
	0x7,
	0x1
};

unsigned char message_polynomial[MESSAGE_LEN] = 
{
	/*power representation*/
	0x1,
	0x4,
	0x4,
	0x2,
	0x7,
	0xD,
	0x6,
	0x0,
	0x6
};
#else
unsigned char power_polynomial_table[GF_FIELD][2] = 
{
	/*power <---> polynomial*/
	/*These are also the coefficients of generator polynomials.*/
	{0xFF, 0x0},
	{0x0, 0x1},
	{0x1, 0x2},
	{0x2, 0x4},
	{0x3, 0x3},
	{0x4, 0x6},
	{0x5, 0x7},
	{0x6, 0x5}
};

unsigned char generator_polynomial[CODEWORD_LEN - MESSAGE_LEN + 1] =
{
	/*generated by MATLAB: genpoly = rsgenpoly(n, k, prim_poly)*/
	0x3,
	0x1,
	0x0,
	0x3,
	0x1
};

unsigned char message_polynomial[MESSAGE_LEN] = 
{
	/*power representation*/
	0x1,
	0x3,
	0x5
};

#endif

unsigned char gf_pow2poly(unsigned char val_in_pow)
{
	unsigned char val_in_poly = 0;

	return power_polynomial_table[val_in_pow + 1][1];
}

unsigned char gf_poly2pow(unsigned char val_in_poly)
{
	unsigned char i = 0;
	unsigned char val_in_pow = 0;

	for(i = 0; i < GF_FIELD; i++)
	{
		if(power_polynomial_table[i][1] == val_in_poly)
		{
			val_in_pow = power_polynomial_table[i][0];
			break;
		}
	}

	return val_in_pow;
}

unsigned char gf_location(unsigned char val)
{
	unsigned char val_location = power_polynomial_table[val + 1][0];

	return val_location;
}

unsigned char gf_add(unsigned char a, unsigned char b)
{
	unsigned char i = 0;
	unsigned char sum_in_pow = 0;
	
	unsigned char sum_in_poly = gf_pow2poly(a) ^ gf_pow2poly(b);
	sum_in_pow = gf_poly2pow(sum_in_poly);

	return sum_in_pow;
}

unsigned char gf_multp(unsigned char a, unsigned char b)
{
	unsigned char product_in_pow = (a + b) % (GF_FIELD - 1);

	return product_in_pow;
}

unsigned char evaluation_encoding()
{
	unsigned char i = 0, j = 0;
	unsigned char tmp_power_result[MESSAGE_LEN], tmp_add_result = 0;

	unsigned char codeword[CODEWORD_LEN];

	for(i = 0; i < CODEWORD_LEN; i++)
	{
		for(j = 0; j < MESSAGE_LEN; j++)
		{
			tmp_power_result[j] = gf_multp(message_polynomial[j], i * gf_location(j));
		}
		tmp_add_result = 0;
		for(j = 0; j < MESSAGE_LEN; j++)
		{
			tmp_add_result = gf_pow2poly(tmp_power_result[j]) ^ tmp_add_result;
		}

		for(j = 0; j < GF_FIELD; j++)
		{
			codeword[i] = gf_poly2pow(tmp_add_result);
		}
	}

	printf("Evaluation Encoding Codeword:\n");
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		printf("%x ", codeword[i]);
	}
	printf("\n");

	return 0;
}

unsigned char systematic_encoding()
{
	unsigned char i = 0;
	
	unsigned char clock_cycle = 0;
	unsigned char input_message = 0;
	unsigned char feed_back_reg = 0, reg_delay[CODEWORD_LEN - MESSAGE_LEN];
	unsigned char codeword[CODEWORD_LEN];

	/*for iterating calculation, tmp for C, not in HDL*/
	unsigned char feed_back_reg_prev = feed_back_reg, reg_delay_prev[CODEWORD_LEN - MESSAGE_LEN];

	memset(reg_delay, 0xFF, sizeof(unsigned char) * (CODEWORD_LEN - MESSAGE_LEN));
	memset(codeword, 0xFF, sizeof(unsigned char) * CODEWORD_LEN);
	memcpy(reg_delay_prev, reg_delay, sizeof(unsigned char) * (CODEWORD_LEN - MESSAGE_LEN));

	if(0 == clock_cycle)
	{
		input_message = message_polynomial[MESSAGE_LEN - 1 - clock_cycle];
		feed_back_reg = gf_add(input_message, reg_delay[CODEWORD_LEN - MESSAGE_LEN - 1]);
		feed_back_reg_prev = feed_back_reg;
		memcpy(reg_delay_prev, reg_delay, sizeof(unsigned char) * (CODEWORD_LEN - MESSAGE_LEN));
	}
	for(clock_cycle = 1; clock_cycle < (CODEWORD_LEN - MESSAGE_LEN); clock_cycle++)
	{
		for(i = CODEWORD_LEN - MESSAGE_LEN - 1; i >0; i--)
		{
			reg_delay[i] = gf_add(gf_multp(feed_back_reg_prev, generator_polynomial[i]), reg_delay_prev[i - 1]);
		}
		reg_delay[0] = gf_multp(feed_back_reg_prev, generator_polynomial[0]);
		input_message = message_polynomial[MESSAGE_LEN - 1 - clock_cycle];		
		feed_back_reg = gf_add(input_message, reg_delay[CODEWORD_LEN - MESSAGE_LEN - 1]);

		feed_back_reg_prev = feed_back_reg;
		memcpy(reg_delay_prev, reg_delay, sizeof(unsigned char) * (CODEWORD_LEN - MESSAGE_LEN));
	}

	for(i = CODEWORD_LEN - MESSAGE_LEN; i < CODEWORD_LEN; i++)
	{
		codeword[i] = message_polynomial[i - (CODEWORD_LEN - MESSAGE_LEN)];
	}
	for(i = 0; i < CODEWORD_LEN - MESSAGE_LEN; i++)
	{
		codeword[i] = reg_delay[i];
	}

	printf("Systematic Encoding Codeword:\n");
	for(i = 0; i < CODEWORD_LEN; i++)
	{
		printf("%x ", codeword[i]);
	}
	printf("\n");

	return 0;
}
